
#define csd_LED_ADDR	0x41200000

#include "uart_init.s"

.extern csd_main

.align 8

// Our interrupt vector table
csd_entry:
	b csd_reset
	b .
	b .
	b .
	b .
	b .
	b .
	b .

.global main
csd_reset:
main:

	UART_init		// UART Initialization

	ldr r0, =uart_Channel_sts_reg0	//Load UART status register address
	ldr r1, =uart_TX_RX_FIFO0		//Load UART FIFO register address
	ldr	r2, =string					//Load string memory address

	bl UART_print			//Print string to Tera Term
 	ldr r6, =csd_LED_ADDR	//Load led I/O memory address
 	ldr r8, =timerInfo		//Load timer information memory address
 	mov r4, #0b00000001		//Set initial LED status to 1
 	str r4, [r6]			//Update LED status
 	mov r5, #0x2a000000		//Set initial timer to 1 sec

forever:
	ldr r3, [r0]			//Load UART status
	and r3, r3, #1<<1
	cmp r3, #0				//Check if Rx FIFO is empty or not

	ldreq r4, [r1]			//Load from Rx FIFO -> Receive from Tera Term
	streq r4, [r1]			//Store received data to Tx FIFO -> Send to Tera Term

	//Compare received data from Tera Term
	//If received data is between 1 to 8, set timer according to information
	//If received data is not between 1 to 8, don't update timer
	cmp r4, #49
	ldreq r5, [r8]
	beq rotation
	cmp r4, #50
	ldreq r5, [r8, #4]
	beq rotation
	cmp r4, #51
	ldreq r5, [r8, #8]
	beq rotation
	cmp r4, #52
	ldreq r5, [r8, #12]
	beq rotation
	cmp r4, #53
	ldreq r5, [r8, #16]
	beq rotation
	cmp r4, #54
	ldreq r5, [r8, #20]
	beq rotation
	cmp r4, #55
	ldreq r5, [r8, #24]
	beq rotation
	cmp r4, #56
	ldreq r5, [r8, #28]
	beq rotation

rotation:
	mov r7, r5				//Set timer count
	ldr r4, [r6]			//Load current LED status
	lsl r4, r4, #1			//Shift LED status left by 1
	cmp r4, #0b10000000		//Check if LED status is over LED range
	bgt rotateByte			//IF LED status is over LED range, reset LED status to 1


timer:
	subs r7, r7, #1			//Decrease timer count
	bne timer				//If timer count is 0, end timer

 	str r4, [r6]			//Update LED status
 	b forever				//Repeat the program

rotateByte:
	mov r4, #1				//Reset LED status to 1
	b timer					//Return

UART_print:
	ldr r3, [r0]			//Load UART status
	and	r3, r3, #0x8
	cmp	r3, #0x8			//Check if Tx FIFO is empty or not
	bne	UART_print			//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r2], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//
	bne UART_print			//

	mov pc, lr		// return to the caller




	// ---------  Check to see if the Tx FIFO is empty ------------------------------
	ldr r3, [r0]		// read Channel Status Register
	and	r3, r3, #0x8	// read Transmit Buffer Empty bit(bit[3])
	cmp	r3, #0x8		// check if TxFIFO is empty and ready to receive new data
	bne	UART_print			// if TxFIFO is NOT empty, keep checking until it is empty
	//------------------------------------------------------------------------------

	ldrb r4, [r2], #1
	ldr r5, =uart_TX_RX_FIFO0
	strb r4, [r5]	// fill the TxFIFO with 0x48
	cmp r4, #0x00
	bne UART_print

	mov pc, lr		// return to the caller

	.data
string:
	.byte 0x0D
	.byte 0x0A
	.ascii "----------------- LED On Duration ----------------"
	.byte 0x0D
	.byte 0x0A
	.ascii "1. 100ms 2. 200ms 3. 300ms 4. 400 ms"
	.byte 0x0D
	.byte 0x0A
	.ascii "5. 500ms 6. 600ms 7. 700ms 8. 1 sec"
	.byte 0x0D
	.byte 0x0A
	.ascii "---------------------------------------------------"
	.byte 0x0D
	.byte 0x0A
	.ascii "Select:"
	.byte 0x0D
	.byte 0x0A
	.byte 0x00

timerInfo:
	.word 0x04333333, 0x08666666, 0x0c999999, 0x10cccccc, 0x14ffffff, 0x19333332, 0x1d666665, 0x21999998
