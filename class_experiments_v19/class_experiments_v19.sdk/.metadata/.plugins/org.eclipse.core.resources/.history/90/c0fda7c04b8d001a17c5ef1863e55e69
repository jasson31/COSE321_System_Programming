//Author : Jaemin Son
//Date : 2020/4/8
//Description : Sort 32 words from smallest to biggest
//				Insertion sort algorithm was used

#include "uart_init.s"

.global main
main:
	UART_init		// UART Initialization

	ldr r0, =Input_data		//Used for input data address indexing
	ldr r1, =Output_data	//Used for output data address indexing

	sub r9, r1, r0			//Get total data length

	ldr r3, [r0]
 	str r3, [r1]			//Copy 0th index value of input data to output data
	mov r2, #4				//R2 for index of value to insert

	bl debugMacro

insertion_loop:				//Starts insertion sort algorithm
	mov r3, r2				//R3 for insertion loop count
	ldr r4, [r0, r2]		//Load value to insert from input data

find_position:				//Find position to insert value
	sub r6, r3, #4			//R6 for index of value to compare
	ldr r5, [r1, r6]		//Load value to compare from output data

	cmp r4, r5				//Compare values
	bge end_loop			//If value to insert is greater than compared value, insert position is found

	str r5, [r1, r3]		//Push compared value backward

	subs r3, r3, #4			//Decrease loop count
	bne find_position		//If loop count is 0, end insertion loop

end_loop:					//End of the insertion loop
	str r4, [r1, r3]		//Insert the insert value to the position found
	add r2, r2, #4			//Increase the insert value index

	cmp r2, r9				//Compare if insert value index is over total data length
	//blge debugMacro
	bge forever				//If inserted all values, end program

	b insertion_loop		//Do insertion loop again

forever:					//Program ended
	nop
	b forever








debugMacro:
	STMFD R13!, {R0-R15}

	ldr r0, =uart_Channel_sts_reg0	//Load UART status register address
	ldr r1, =uart_TX_RX_FIFO0		//Load UART FIFO register address

	ldr	r11, =HexCode
	ldr	r12, =string

	mov r3, #0

printRegisters:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printRegisters			//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldr r8, [R13, r3]

printRegisterName:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printRegisterName	//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r12], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//Check if string is end
	bne printRegisterName			//If string is not end, repeat print

	mov r6, #28
	mov r7, #0xF0000000
printHexMain:
	and r9, r8, r7
	mov r9, r9, lsr r6
	add r5, r11, r9
	ldrb r5, [r5]
	strb r5, [r1]			//Store one character from string to Tx FIFO

	cmp r6, #16
	moveq r5, #95
	streqb r5, [r1]

	sub r6, r6, #4
	mov r7, r7, lsr #4
	cmp r6, #-4
	bne printHexMain


	add r3, r3, #4
	cmp r3, #64
	bne printRegisters


	mrs r3, cpsr
printNZCV:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printNZCV	//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r12], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//Check if string is end
	bne printNZCV			//If string is not end, repeat print

	and r4, r3, #0xf0000000
	mov r4, r4, lsr #28
	mov r5, #5
	mul r4, r4, r5
	ldr r5, =NZCVCode
	add r5, r5, r4

printNZCVStatus:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printNZCVStatus	//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r5], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//Check if string is end
	bne printNZCVStatus			//If string is not end, repeat print




printAIF:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printAIF	//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r12], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//Check if string is end
	bne printAIF			//If string is not end, repeat print




















printStringLeft:
	ldr r2, [r0]			//Load UART status
	and	r2, r2, #0x8
	cmp	r2, #0x8			//Check if Tx FIFO is empty or not
	bne	printStringLeft	//If Tx FIFO is not empty, loop this until Tx FIFO is empty

	ldrb r4, [r12], #1		//Load one character from string
	strb r4, [r1]			//Store one character from string to Tx FIFO
	cmp r4, #0x00			//Check if string is end
	bne printStringLeft			//If string is not end, repeat print



	ldmfd r13!, {r0-r12}
	ldr r14, [r13, #4]
	ldr r13, [r13]

	mov pc, lr








.data
.align 4
Input_data:	.word 2, 0, -7, -1, 3, 8, -4, 10
			.word -9, -16, 15, 13, 1, 4, -3, 14
			.word -8, -10, -15, 6, -13, -5, 9, 12
			.word -11, -14, -6, 11, 5, 7, -2, -12
Output_data:	.word 0, 0, 0, 0, 0, 0, 0, 0
				.word 0, 0, 0, 0, 0, 0, 0, 0
				.word 0, 0, 0, 0, 0, 0, 0, 0
				.word 0, 0, 0, 0, 0, 0, 0, 0

HexCode:
	.ascii "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"

NZCVCode:
	.ascii "nzcv"
	.byte 0x00
	.ascii "nzcV"
	.byte 0x00
	.ascii "nzCv"
	.byte 0x00
	.ascii "nzCV"
	.byte 0x00
	.ascii "nZcv"
	.byte 0x00
	.ascii "nZcV"
	.byte 0x00
	.ascii "nZCv"
	.byte 0x00
	.ascii "nZCV"
	.byte 0x00
	.ascii "Nzcv"
	.byte 0x00
	.ascii "NzcV"
	.byte 0x00
	.ascii "NzCv"
	.byte 0x00
	.ascii "NzCV"
	.byte 0x00
	.ascii "NZcv"
	.byte 0x00
	.ascii "NZcV"
	.byte 0x00
	.ascii "NZCv"
	.byte 0x00
	.ascii "NZCV"

AIFCode:
	.ascii "aif"
	.byte 0x00
	.ascii "aiF"
	.byte 0x00
	.ascii "aIf"
	.byte 0x00
	.ascii "aIF"
	.byte 0x00
	.ascii "Aif"
	.byte 0x00
	.ascii "AiF"
	.byte 0x00
	.ascii "AIf"
	.byte 0x00
	.ascii "AIF"

ModeCode:
	.ascii "usr"
	.byte 0x00
	.ascii "fiq"
	.byte 0x00
	.ascii "irq"
	.byte 0x00
	.ascii "svc"
	.byte 0x00
	.ascii "mon"
	.byte 0x00
	.ascii "abt"
	.byte 0x00
	.ascii "hyp"
	.byte 0x00
	.ascii "und"
	.byte 0x00
	.ascii "sys"

CModeCode:
	.ascii "ARM    "
	.byte 0x00
	.ascii "Thumb  "
	.byte 0x00
	.ascii "Jazelle"
	.byte 0x00
	.ascii "ThumbEE"

string:
	.byte 0x0D, 0x0A
	.ascii "-----------------------------------------------------------------------------------------------------"
	.byte 0x0D, 0x0A
	.ascii "r0 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r1 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r2 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r3 = 0x"
	.byte 0x00, 0x0D, 0x0A
	.ascii "r4 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r5 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r6 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r7 = 0x"
	.byte 0x00, 0x0D, 0x0A
	.ascii "r8 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r9 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r10 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r11 = 0x"
	.byte 0x00, 0x0D, 0x0A
	.ascii "r12 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r13 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r14 = 0x"
	.byte 0x00, 0x2C, 0x09
	.ascii "r15 = 0x"
	.byte 0x00, 0x0D, 0x0A
	.ascii "cpsr = "
	.byte 0x00, 0x2C, 0x09
	.byte 0x00, 0x2C, 0x09
	.ascii " mode"
	.byte 0x00, 0x2C, 0x09
	.ascii "current mode = "
	.byte 0x00, 0x2C, 0x09
	.ascii " ( =0x"
	.byte 0x00
	.ascii ")"
	.byte 0x0D, 0x0A
	.ascii "-----------------------------------------------------------------------------------------------------"
	.byte 0x0D, 0x0A, 0x00

/*string:
	.byte 0x0D
	.byte 0x0A
	.ascii "-----------------------------------------------------------------------------------------------------"
	.byte 0x0D
	.byte 0x0A
	.ascii "r0 = 0x1000_0123, r1 = 0xffee_0112, r2 = 0x9800_ab00, r3 = 0xfe03_0010"
	.byte 0x0D
	.byte 0x0A
	.ascii "r4 = 0xffff_1000, r5 = 0xc123_0112, r6 = 0x1800_1100, r7 = 0xbe10_0030"
	.byte 0x0D
	.byte 0x0A
	.ascii "r8 = 0x2200_0140, r9 = 0x55ee_0112, r10 = 0x1200_1200, r11 = 0x9803_2210"
	.byte 0x0D
	.byte 0x0A
	.ascii "r12 = 0x3300_0100, r13 = 0xccee_0112, r14 = 0x3400_ab00, r15 = 0x0010_0304"
	.byte 0x0D
	.byte 0x0A
	.ascii "cpsr = nZCv, IF, ARM mode, current mode = SVC ( =0x6000_00d3)"
	.byte 0x0D
	.byte 0x0A
	.ascii "-----------------------------------------------------------------------------------------------------"
	.byte 0x0D
	.byte 0x0A
	.byte 0x00*/
